// Sequence Item
class packet_item extends uvm_sequence_item;
  rand bit [7:0] id;
  rand bit [31:0] addr;
  rand bit [31:0] data;
  rand int delay_cycles; // delay between addr and data (1-10)

  constraint valid_delay { delay_cycles inside {[1:10]}; }

  `uvm_object_utils(packet_item)

  function new(string name = "packet_item");
    super.new(name);
  endfunction

  function void do_copy(uvm_object rhs);
    packet_item rhs_;
    if (!$cast(rhs_, rhs)) `uvm_fatal("COPY_FAIL", "Type cast failed")
    super.do_copy(rhs);
    this.id           = rhs_.id;
    this.addr         = rhs_.addr;
    this.data         = rhs_.data;
    this.delay_cycles = rhs_.delay_cycles;
  endfunction
endclass

// Sequence
class packet_sequence extends uvm_sequence #(packet_item);
  `uvm_object_utils(packet_sequence)

  // ID Pool
  static bit [7:0] free_id_q[$];

  function new(string name = "packet_sequence");
    super.new(name);
  endfunction

  // Initialize the ID pool
  static function void init_ids();
    if (free_id_q.size() == 0) begin
      foreach (free_id_q[i]) free_id_q.delete(i);
      for (int i = 0; i < 256; i++)
        free_id_q.push_back(i);
    end
  endfunction

  virtual task body();
    packet_item pkt;
    init_ids();

    for (int i = 0; i < 5; i++) begin
      pkt = packet_item::type_id::create("pkt");

      // Wait until an ID is available
      wait (free_id_q.size() > 0);
      pkt.id = free_id_q.pop_front();

      assert(pkt.randomize() with { id == pkt.id; });
      start_item(pkt);
      finish_item(pkt);
    end
  endtask

  // External function to return ID back to pool
  static function void release_id(bit [7:0] id);
    free_id_q.push_back(id);
  endfunction
endclass

// Driver
class packet_driver extends uvm_driver #(packet_item);
  `uvm_component_utils(packet_driver)

  virtual dut_if vif;
  packet_item in_order_data_storage[$];

  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction

  virtual task run_phase(uvm_phase phase);
    packet_item pkt;

    forever begin
      seq_item_port.get_next_item(pkt);
      fork
        drive_addr(pkt);
        begin
          repeat(pkt.delay_cycles) @(posedge vif.clk);
          drive_data(pkt);
        end
      join_none
      seq_item_port.item_done();
    end
  endtask

  task drive_addr(packet_item pkt);
    vif.avalid <= 1;
    vif.a_id   <= pkt.id;
    vif.addr   <= pkt.addr;
    in_order_data_storage.push_back(pkt);
    `uvm_info("DRIVER", $sformatf("Sent ADDR: id=%0d addr=0x%08X", pkt.id, pkt.addr), UVM_MEDIUM)
    @(posedge vif.clk);
    vif.avalid <= 0;
  endtask

  task drive_data(packet_item dummy);
    packet_item data;
    data = in_order_data_storage.pop_front();
    vif.dvalid <= 1;
    vif.d_id   <= data.id;
    vif.data   <= data.data;
    `uvm_info("DRIVER", $sformatf("Sent DATA: id=%0d data=0x%08X", data.id, data.data), UVM_MEDIUM)
    @(posedge vif.clk);
    vif.dvalid <= 0;
  endtask
endclass

// Monitor
class packet_monitor extends uvm_component;
  `uvm_component_utils(packet_monitor)

  virtual dut_if vif;
  uvm_analysis_port #(packet_item) ap;

  function new(string name, uvm_component parent);
    super.new(name, parent);
    ap = new("ap", this);
  endfunction

  virtual task run_phase(uvm_phase phase);
    forever begin
      @(posedge vif.clk);
      if (vif.o_avalid && vif.o_dvalid) begin
        packet_item pkt = packet_item::type_id::create("pkt");
        pkt.id   = vif.o_a_id;
        pkt.addr = vif.o_addr;
        pkt.data = vif.o_data;
        ap.write(pkt);
        `uvm_info("MONITOR", $sformatf("RECEIVED OUT: id=%0d addr=0x%08X data=0x%08X", pkt.id, pkt.addr, pkt.data), UVM_MEDIUM)
        packet_sequence::release_id(pkt.id);
      end
    end
endtask
.......................................................................................................................
/*In your DUT, address and data can come at different times, and the order of data must match the order of addresses.

That means:

You might issue drive_addr(pkt) for pkt.id = 3 now...

Then delay a few cycles (via repeat(pkt.delay_cycles))

Then call drive_data(pkt)...

But in between, other addresses might have been driven because drive_addr is inside a fork, which allows concurrent threads. */

/* This means the address and delayed-data-driving run in parallel in background threads. Then, you immediately call:

seq_item_port.item_done();
So the driver is free to grab the next transaction from the sequencer in the next iteration of the loop.

This is exactly how pipelining and concurrent transaction generation is simulated. */

| Cycle | addr phase | data phase          |
| ----- | ---------- | ------------------- |
| 0     | addr pkt1  |                     |
| 1     | addr pkt2  |                     |
| 2     |            | data pkt2 (delay=1) |
| 3     |            |                     |
| 4     |            | data pkt1 (delay=3) |
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
| Cycle | Address Phase      | Data Phase         |
| ----- | ------------------ | ------------------ |
| 0     | `drive_addr(pkt1)` |                    |
| 1     | `drive_addr(pkt2)` |                    |
| 2     |                    | `drive_data(pkt2)` |
| 3     |                    |                    |
| 4     |                    | `drive_data(pkt1)` |
Let’s assume:

pkt1.id = 10, delay = 4

pkt2.id = 20, delay = 1

-----------------------------------------------------------
At Cycle 0:
pkt1 is passed to drive_addr(pkt1)

in_order_data_storage.push_back(pkt1);
This adds pkt1 to the back of the queue

At Cycle 1:
pkt2 arrives, goes through drive_addr(pkt2), and also gets:

in_order_data_storage.push_back(pkt2);
Now in_order_data_storage contains:

[ pkt1, pkt2 ]

At Cycle 2:
drive_data(pkt2) fires because its delay was shorter

BUT in drive_data:
data = in_order_data_storage.pop_front();

This pops pkt1, which was pushed first

So even though pkt2 is ready, pkt1 is sent first — In order.

If you push_back(pkt) at drive_addr(pkt) time, and pop_front() at data time, you're forcing in-order data, even if pkt2's delay is shorter.

And your queue does exactly that:

Even though pkt2 has a smaller delay,

drive_data(pkt2) will pop and send pkt1’s data first

This preserves the in-order constraint
.........................................................................................




